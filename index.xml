<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>yyer的个人博客</title>
    <link>https://jianqiao1.github.io/</link>
    <description>Recent content on yyer的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 10 Aug 2020 22:19:58 +0800</lastBuildDate>
    
	<atom:link href="https://jianqiao1.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>链表专题</title>
      <link>https://jianqiao1.github.io/post/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</link>
      <pubDate>Mon, 10 Aug 2020 22:19:58 +0800</pubDate>
      
      <guid>https://jianqiao1.github.io/post/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</guid>
      <description>PAT A   1074 Reversing Linked List (25分) 1032 Sharing (25分) 1052 Linked List Sorting (25分) 1097 Deduplication on a Linked List (25分)  不同于力扣，上面四题，链表的每个节点信息一般用Node结构体存储，并借助STL中vector/map/set等操作节点位置。
 力扣   力扣21.合并两个有序链表  思路：递归，这里没有构造新节点，递归可以看做为栈的实现
class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1==nullptr) return l2; if(l2==nullptr) return l1; if(l1-&amp;gt;val&amp;lt;l2-&amp;gt;val) {l1-&amp;gt;next=mergeTwoLists(l1-&amp;gt;next,l2);return l1;} else {l2-&amp;gt;next=mergeTwoLists(l1,l2-&amp;gt;next);return l2;} } };  力扣24.两两交换链表中的节点  给定一个链表，两两交换其中相邻的节点，并返回交换后的链表，题目要求不能只是单纯的改变节点内部的值，而需要实际的进行节点交换。所以这里我们就不好借助什么vector数组存放并交换数值位置最后直接一个一个用curr-&amp;gt;val==vec[i]进行更改了，这里我们得原地直接交换链表指针，可以采用迭代法和递归法。
递归法于我来说还是那么的不好理解虽然代码很简洁，看起来就是不断地调用递归函数进行层层深入，每次调用函数有一个返回值，多次调用遇到终止条件就结束递归操作。
迭代法可以先构造一个哑结点的下一个节点指向head,再让pre指向该哑结点，并且让函数循环的条件是pre-&amp;gt;next!=nullptr&amp;amp;&amp;amp;pre-&amp;gt;next-&amp;gt;next!=nullptr,在循环体内就是针对pre,pre-&amp;gt;next,pre-&amp;gt;next-&amp;gt;next进行链表指针交换，四个交换如下
ListNode* start=pre-&amp;gt;next; ListNode* end=pre-&amp;gt;next-&amp;gt;nex pre-&amp;gt;next=start-&amp;gt;next; start-&amp;gt;next=end-&amp;gt;next; end-&amp;gt;next=start; pre=start; 递归代码</description>
    </item>
    
    <item>
      <title>A1047</title>
      <link>https://jianqiao1.github.io/post/a1047/</link>
      <pubDate>Sun, 09 Aug 2020 23:46:47 +0800</pubDate>
      
      <guid>https://jianqiao1.github.io/post/a1047/</guid>
      <description>1074 Reversing Linked List   题目大意：输入：第一行输入三个值，给定第一个节点的地址addr、链表总节点的个数n、k值,其中k值表示原链表每k个翻转，不满k个不翻转。
第2行到第1+n行为链表每一个节点的地址，节点对应的数值，节点的下一个节点地址。
输出：输出翻转后的链表，共有n行，每行要输出的内容为当前节点的地址、当前节点的数值、下一个节点的地址。
   解题思路：
题目需要我们先按照每个节点对应的地址以及它的下一个节点的地址作为索引，将每一个节点一个接一个链接起来，然后每k个节点翻转，若剩下的节点不满k个就不翻转。由于题目将地址作为节点的索引，我们顺其自然就可以想到用struct结构体，其中有三个变量：节点的地址、节点的数值、节点的下一个节点地址。这里当我们存结构体信息时，直接将当前节点的地址作为结构体变量的索引，即addr;然后依次存入node[addr].data和node[addr].next，这里可能会有疑惑：如果直接将addr作为结构体变量的索引，那如何得到node[addr].addr,其实我们知道node[addr].addr=addr,那我们可以写一个初始化函数，令node[i].addr=i,这样就解决了前面的问题。
第二个问题就是题目要求当节点排好后还要以每k个节点翻转，那我们可以定义一个vector数组，借助reverse函数进行反转。这里开始从来就没想过还可以定义vector&amp;lt;Node&amp;gt;形式数组，因为在代码里我们已经定义了一个struct Node{};形式的数据类型。这样就很好做了，接下来我们要知道怎么依据当前节点地址和下一个节点地址来排好节点并存入vector数组中，我们先从题目给定的第一个节点的地址p入手，将该节点存入vector，然后将当前节点的下一个节点地址赋值给p，结束条件是p==-1,这样我们就存入了最初的节点排序。
这里由于输入数据太多容易输错，就用C++文件读写操作将输入输出数据分别存入不同文件中。
   代码
 #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;fstream&amp;gt;#include &amp;lt;iomanip&amp;gt;using namespace std; const int maxn=1e5+5; struct Node{ int addr,data,next; }node[maxn]; void init(){ for(int i=0;i&amp;lt;maxn;i++) node[i].addr=i; } int main(){ ifstream infile; ofstream outfile; infile.open(&amp;#34;C:\\Users\\jianqiao\\Desktop\\a.txt&amp;#34;,ios::in); if(!infile.is_open()) cout&amp;lt;&amp;lt;&amp;#34;Open file failure&amp;#34;&amp;lt;&amp;lt;endl; int head,len,k,addr; vector&amp;lt;Node&amp;gt; vec; //cin&amp;gt;&amp;gt;head&amp;gt;&amp;gt;len&amp;gt;&amp;gt;k; 	infile&amp;gt;&amp;gt;head&amp;gt;&amp;gt;len&amp;gt;&amp;gt;k; init(); /*for(int i=0;i&amp;lt;len;i++){ scanf(&amp;#34;%d&amp;#34;,&amp;amp;addr); scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;node[addr].data,&amp;amp;node[addr].next); }*/ while(0!</description>
    </item>
    
    <item>
      <title>递归解法</title>
      <link>https://jianqiao1.github.io/post/%E9%80%92%E5%BD%92/</link>
      <pubDate>Tue, 21 Jul 2020 16:59:50 +0800</pubDate>
      
      <guid>https://jianqiao1.github.io/post/%E9%80%92%E5%BD%92/</guid>
      <description>力扣 21.合并两个有序链表
将两个升序链表合并为一个新的升序链表并返回，新链表是通过拼接给定的两个链表的所有节点组成的。
示例：
输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1-&amp;gt;val&amp;lt;=l2-&amp;gt;val){ l1-&amp;gt;next=mergeTwoLists(l1-&amp;gt;next,l2); return l1; } l2-&amp;gt;next=mergeTwoLists(l1,l2-&amp;gt;next); return l2; } };   力扣 344.</description>
    </item>
    
    <item>
      <title>Spring Boot实战合集</title>
      <link>https://jianqiao1.github.io/post/blog/</link>
      <pubDate>Tue, 21 Jul 2020 09:51:11 +0800</pubDate>
      
      <guid>https://jianqiao1.github.io/post/blog/</guid>
      <description>本项目为 《Spring Boot实战合集》的系列文章，代码已开源，并持续保持更新。如果您觉得该项目对您有用，欢迎点击右上方的 Star按钮支持一波！！  个人博客：https://www.codesheep.cn GitHub：https://github.com/hansonwang99  另外所有内容都在我的个人微信公众号 CodeSheep 最先推出，大家可以关注一下，可 长按 或 扫描 下面的 小心心 来获取更多 务实、能看懂、可复现的 原创文。除此之外 提问/进群交流 也可以扫码进行！！！
  
  数据库/缓存相关   Guava Cache本地缓存在 Spring Boot应用中的实践
  EVCache缓存在 Spring Boot中的实战
  Spring Boot应用缓存实践之：Ehcache加持
  Spring Boot集成 MyBatis和 SQL Server实践
  Elasticsearch搜索引擎在Spring Boot中的实践
  自制一个 elasticsearch-spring-boot-starter
  Spring Boot项目利用MyBatis Generator进行数据层代码自动生成
  Mybatis-Plus 真好用（乡村爱情加持）
   日志相关  Spring Boot日志框架实践   应用监控相关   利用神器 BTrace 追踪线上 Spring Boot应用运行时信息</description>
    </item>
    
  </channel>
</rss>