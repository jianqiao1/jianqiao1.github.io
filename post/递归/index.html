<!doctype html>
<html lang="en-us">
  <head>
    <title>递归解法 // yyer的个人博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.74.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://jianqiao1.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="递归解法"/>
<meta name="twitter:description" content="力扣 21.合并两个有序链表
将两个升序链表合并为一个新的升序链表并返回，新链表是通过拼接给定的两个链表的所有节点组成的。
示例：
输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1-&gt;val&lt;=l2-&gt;val){ l1-&gt;next=mergeTwoLists(l1-&gt;next,l2); return l1; } l2-&gt;next=mergeTwoLists(l1,l2-&gt;next); return l2; } };   力扣 344."/>

    <meta property="og:title" content="递归解法" />
<meta property="og:description" content="力扣 21.合并两个有序链表
将两个升序链表合并为一个新的升序链表并返回，新链表是通过拼接给定的两个链表的所有节点组成的。
示例：
输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1==NULL) return l2; if(l2==NULL) return l1; if(l1-&gt;val&lt;=l2-&gt;val){ l1-&gt;next=mergeTwoLists(l1-&gt;next,l2); return l1; } l2-&gt;next=mergeTwoLists(l1,l2-&gt;next); return l2; } };   力扣 344." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jianqiao1.github.io/post/%E9%80%92%E5%BD%92/" />
<meta property="article:published_time" content="2020-07-21T16:59:50+08:00" />
<meta property="article:modified_time" content="2020-07-21T16:59:50+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://jianqiao1.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>yyer的个人博客</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/jianqiao1" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">递归解法</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jul 21, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div></div>
    </header>
    <div class="post-content">
      <ul>
<li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">力扣 21.合并两个有序链表</a><br>
将两个升序链表合并为一个新的<strong>升序</strong>链表并返回，新链表是通过拼接给定的两个链表的所有节点组成的。<br>
<strong>示例：</strong><br>
输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Definition for singly-linked list.
</span><span style="color:#75715e"> * struct ListNode {
</span><span style="color:#75715e"> *     int val;
</span><span style="color:#75715e"> *     ListNode *next;
</span><span style="color:#75715e"> *     ListNode() : val(0), next(nullptr) {}
</span><span style="color:#75715e"> *     ListNode(int x) : val(x), next(nullptr) {}
</span><span style="color:#75715e"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}
</span><span style="color:#75715e"> * };
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    ListNode<span style="color:#f92672">*</span> mergeTwoLists(ListNode<span style="color:#f92672">*</span> l1, ListNode<span style="color:#f92672">*</span> l2) {
        <span style="color:#66d9ef">if</span>(l1<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span> l2;
        <span style="color:#66d9ef">if</span>(l2<span style="color:#f92672">==</span>NULL) <span style="color:#66d9ef">return</span> l1;
        <span style="color:#66d9ef">if</span>(l1<span style="color:#f92672">-&gt;</span>val<span style="color:#f92672">&lt;=</span>l2<span style="color:#f92672">-&gt;</span>val){
            l1<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>mergeTwoLists(l1<span style="color:#f92672">-&gt;</span>next,l2);
            <span style="color:#66d9ef">return</span> l1;
        }
        l2<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span>mergeTwoLists(l1,l2<span style="color:#f92672">-&gt;</span>next);
        <span style="color:#66d9ef">return</span> l2;
    }
};  
</code></pre></div><hr>
<ul>
<li><a href="https://leetcode-cn.com/problems/reverse-string/">力扣 344.反转字符串</a><br>
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。<br>
不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。<br>
<strong>示例1：</strong><br>
输入：[&ldquo;h&rdquo;,&ldquo;e&rdquo;,&ldquo;l&rdquo;,&ldquo;l&rdquo;,&ldquo;o&rdquo;]<br>
输出：[&ldquo;o&rdquo;,&ldquo;l&rdquo;,&ldquo;l&rdquo;,&ldquo;e&rdquo;,&ldquo;h&rdquo;]<br>
<strong>示例2：</strong><br>
输入：[&ldquo;H&rdquo;,&ldquo;a&rdquo;,&ldquo;n&rdquo;,&ldquo;n&rdquo;,&ldquo;a&rdquo;,&ldquo;h&rdquo;]<br>
输出：[&ldquo;h&rdquo;,&ldquo;a&rdquo;,&ldquo;n&rdquo;,&ldquo;n&rdquo;,&ldquo;a&rdquo;,&ldquo;H&rdquo;]</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Java" data-lang="Java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> <span style="color:#f92672">{</span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">helper</span><span style="color:#f92672">(</span><span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> s<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> left<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> right<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">&gt;=</span> right<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">char</span> tmp <span style="color:#f92672">=</span> s<span style="color:#f92672">[</span>left<span style="color:#f92672">];</span>
    s<span style="color:#f92672">[</span>left<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">[</span>right<span style="color:#f92672">];</span>
    s<span style="color:#f92672">[</span>right<span style="color:#f92672">--]</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>
    helper<span style="color:#f92672">(</span>s<span style="color:#f92672">,</span> left<span style="color:#f92672">,</span> right<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>

  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reverseString</span><span style="color:#f92672">(</span><span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    helper<span style="color:#f92672">(</span>s<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>   
</code></pre></div><hr>
<ul>
<li><a href="https://leetcode-cn.com/problems/hanota-lcci/">力扣 面试题 08.06. 汉诺塔问题</a><br>
在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一
开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。
请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。
你需要原地修改栈。
<strong>示例1：</strong><br>
输入：A=[2,1,0], B=[], C=[]<br>
输出：C=[2,1,0]<br>
<strong>示例2：</strong><br>
输入：A=[1,0], B=[], C=[]<br>
输出：C=[1,0]<br>
提示：<br>
A中盘子的数目不大于14个</li>
</ul>
<blockquote>
<ul>
<li>n=1时，直接把盘子从A移到C;</li>
<li>n&gt;1时，
先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；
再将最大的盘子从 A 移到 C；
再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）。</li>
</ul>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> hanota(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> B, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> C) {
        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> A.size();
        move(n, A, B, C);
    }

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">move</span>(<span style="color:#66d9ef">int</span> n, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> B, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> C){
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>){
            C.push_back(A.back());
            A.pop_back();
            <span style="color:#66d9ef">return</span>;
        }

        move(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, A, C, B);    <span style="color:#75715e">// 将A上面n-1个通过C移到B
</span><span style="color:#75715e"></span>        C.push_back(A.back());  <span style="color:#75715e">// 将A最后一个移到C
</span><span style="color:#75715e"></span>        A.pop_back();          <span style="color:#75715e">// 这时，A空了
</span><span style="color:#75715e"></span>        move(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, B, A, C);     <span style="color:#75715e">// 将B上面n-1个通过空的A移到C
</span><span style="color:#75715e"></span>    }
};  
</code></pre></div><hr>
<ul>
<li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">力扣 24.两两交换链表中的节点</a><br>
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
<strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。<br>
<strong>示例：</strong><br>
给定1-&gt;2-&gt;3-&gt;4,你应该返回2-&gt;1-&gt;4-&gt;3.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//C++ 常规迭代法
</span><span style="color:#75715e"></span><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Definition for singly-linked list.
</span><span style="color:#75715e"> * struct ListNode {
</span><span style="color:#75715e"> *     int val;
</span><span style="color:#75715e"> *     ListNode *next;
</span><span style="color:#75715e"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span style="color:#75715e"> * };
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> 
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    ListNode<span style="color:#f92672">*</span> swapPairs(ListNode<span style="color:#f92672">*</span> head) 
    {
        <span style="color:#75715e">//新建一个空结点，用来指向头节点
</span><span style="color:#75715e"></span>        ListNode<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ListNode(<span style="color:#ae81ff">0</span>);
        p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head;
        <span style="color:#75715e">//新建和p相同一个curr节点，两个相同的节点一个是当前做改变的节点，一个是保持不动用来返回的节点
</span><span style="color:#75715e"></span>        ListNode<span style="color:#f92672">*</span> curr <span style="color:#f92672">=</span> p;
        <span style="color:#75715e">//循环条件为当前节点为NULL或当前的下一个节点为NULL，分别对应偶数和奇数个节点的终止标志
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(head <span style="color:#f92672">!=</span> NULL <span style="color:#f92672">&amp;&amp;</span> head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL)
        {
            <span style="color:#75715e">//为了清晰明了，我们新建两个节点，一节点和二节点
</span><span style="color:#75715e"></span>            ListNode<span style="color:#f92672">*</span> firstNode <span style="color:#f92672">=</span> head;
            ListNode<span style="color:#f92672">*</span> secondNode <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;

            <span style="color:#75715e">///把一和二进行交换，并连接前后
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//当前curr节点指向二节点
</span><span style="color:#75715e"></span>            curr<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> secondNode;
            <span style="color:#75715e">//一节点指向二节点此时的下一节点
</span><span style="color:#75715e"></span>            firstNode<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> secondNode<span style="color:#f92672">-&gt;</span>next;
            <span style="color:#75715e">//二节点指向一节点，即交换位置成功
</span><span style="color:#75715e"></span>            secondNode<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> firstNode;

            <span style="color:#75715e">//由于每次循环curr节点都指向每次循环的一节点，所以要再次把curr节点指向一节点
</span><span style="color:#75715e"></span>            curr <span style="color:#f92672">=</span> firstNode;
            <span style="color:#75715e">//每次移动都是由head节点来赋值操作，所以head应向右移动两格，即新循环的一节点
</span><span style="color:#75715e"></span>            head <span style="color:#f92672">=</span> firstNode<span style="color:#f92672">-&gt;</span>next;
        }
        <span style="color:#75715e">//返回p的下一个节点即对应整个操作后的链表
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> p<span style="color:#f92672">-&gt;</span>next;

    }
};   
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//C++递归法
</span><span style="color:#75715e"></span><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Definition for singly-linked list.
</span><span style="color:#75715e"> * struct ListNode {
</span><span style="color:#75715e"> *     int val;
</span><span style="color:#75715e"> *     ListNode *next;
</span><span style="color:#75715e"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span style="color:#75715e"> * };
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> 
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    ListNode<span style="color:#f92672">*</span> swapPairs(ListNode<span style="color:#f92672">*</span> head) 
    {
        <span style="color:#75715e">///终止条件为所有都交换完了的链表
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(head <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">==</span> NULL)
            <span style="color:#66d9ef">return</span> head;
        <span style="color:#75715e">///递归单元内两个节点做交换
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//定义一个p结点为head-&gt;next(该递归单元内第二个节点)
</span><span style="color:#75715e"></span>        ListNode <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> head<span style="color:#f92672">-&gt;</span>next;
        <span style="color:#75715e">//记录第三个节点同时也是下一次递归的head
</span><span style="color:#75715e"></span>        ListNode <span style="color:#f92672">*</span>temp <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
        <span style="color:#75715e">//使此单元内第二个节点指向第一个节点，即交换位置
</span><span style="color:#75715e"></span>        p<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> head;
        <span style="color:#75715e">//交换完成后的head应指向下一次单元返回的头节点
</span><span style="color:#75715e"></span>        head<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> swapPairs(temp);
        <span style="color:#75715e">//返回该单元的头节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> p;

    }
};   
</code></pre></div><hr>
<ul>
<li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">力扣 104.二叉树的最大深度</a><br>
给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//DFS
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxDepth</span>(TreeNode root) {
    <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> null) {
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    } <span style="color:#66d9ef">else</span> {
      <span style="color:#66d9ef">int</span> left_height <span style="color:#f92672">=</span> maxDepth(root.left);
      <span style="color:#66d9ef">int</span> right_height <span style="color:#f92672">=</span> maxDepth(root.right);
      <span style="color:#66d9ef">return</span> max(left_height, right_height) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    }
  }
}  
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">//BFS  
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">maxDepth</span>(TreeNode root) {
     <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> null) {
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        }
        <span style="color:#75715e">// bfs
</span><span style="color:#75715e"></span>        Queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;</span>();
        <span style="color:#66d9ef">int</span> depth <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        queue.add(root);
        <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>queue.isEmpty()) {
            <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> queue.size();
            depth<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">++</span>) {
                TreeNode temp <span style="color:#f92672">=</span> queue.poll();
                <span style="color:#66d9ef">if</span> (temp.left <span style="color:#f92672">!=</span> null) {
                    queue.add(temp.left);
                }
                <span style="color:#66d9ef">if</span> (temp.right <span style="color:#f92672">!=</span> null) {
                    queue.add(temp.right);
                }
            }
        }
        <span style="color:#66d9ef">return</span> depth; 
  }
} 
</code></pre></div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
